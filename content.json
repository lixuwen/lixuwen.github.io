{"meta":{"title":"小巨人的技术博客","subtitle":null,"description":null,"author":"小巨人","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"计算可变参数列表长度","slug":"计算可变参数列表长度","date":"2017-10-24T09:26:57.000Z","updated":"2017-10-24T10:37:11.000Z","comments":true,"path":"2017/10/24/计算可变参数列表长度/","link":"","permalink":"http://yoursite.com/2017/10/24/计算可变参数列表长度/","excerpt":"","text":"接到题目，第一反应就是通过 va_list va_start va_arg va_end 等参数列表API遍历计算参数列表长度，函数方法如下： 1234567891011121314151617181920212223- (NSInteger)mutableArgumentsCount:(NSString *)firstArg, ... NS_REQUIRES_NIL_TERMINATION&#123; NSInteger count = 0; if(!firstArg) &#123; return count; &#125; count = 1; va_list args; NSString *arg; va_start(args, firstArg); while ((arg = va_arg(args, NSString *))) &#123; count += 1; &#125; va_end(args); return count;&#125;NSInteger count = [self mutableArgumentsCount:@\"Hello\", @\"world\", @\"!\", nil]; // count = 3 非常简单，但是这个需要执行一下这个才能得出参数列表长度；其实对于可变参数列表在编译阶段就已经确定入参了，想想看，是不是对于有参数是··· 的方法，我们在使用时其实已经传入了确定的参数。 那有什么方法在编译阶段可以计算出可变参数列表的长度呢？ ReactiveCocoa 的 RACmetamacros.h 文件中有一系列宏可以搞定这个事情。 1NSInteger count = metamacro_argcount(@\"Hello\", @\"world\", @\"!\"); // count = 3 让我们一步一步展开这个宏看个究竟。 第一步： 展开metamacro_argcount 12#define metamacro_argcount(...) \\ metamacro_at(20, __VA_ARGS__, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1) metamacro_argcount中包含metamacro_at这个宏，展开后结果为 1NSInteger count = metamacro_at(20, @\"Hello\", @\"world\", @\"!\", 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1); 第二步： 展开metamacro_at 12#define metamacro_at(N, ...) \\ metamacro_concat(metamacro_at, N)(__VA_ARGS__) metamacro_at中包含metamacro_concat这个宏，展开后结果为 1NSInteger count = metamacro_concat(metamacro_at, 20)(@\"Hello\", @\"world\", @\"!\", 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1); 第三步： 展开metamacro_concat 1234#define metamacro_concat(A, B) \\ metamacro_concat_(A, B) #define metamacro_concat_(A, B) A ## B metamacro_concat的作用最终就是把两个参数拼接，如metamacro_concat(a, b)得出的结果就是ab，既然如此，展开metamacro_concat的结果为 1NSInteger count = metamacro_at20(@\"Hello\", @\"world\", @\"!\", 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1); 这里有个巧妙之处就是通过metamacro_concat的作用得出一个新的宏metamacro_at20，让我们继续展开。 第四步： 展开metamacro_at20 1#define metamacro_at20(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, ...) metamacro_head(__VA_ARGS__) metamacro_at20这个宏需要20个参数作为固定参数，剩下的作为可变参数来处理，这一步相当于截断了前20个参数，留下剩下几个参数来使用。作者不仅仅定义了metamacro_at20这个宏，还定义了好多类似的宏。 真是一步比一步巧妙，我们已经迫不及待的想把metamacro_at20展开了 1NSInteger count = metamacro_head(3, 2, 1); 第五步： 展开metamacro_head 1234#define metamacro_head(...) \\ metamacro_head_(__VA_ARGS__, 0) #define metamacro_head_(FIRST, ...) FIRST 看到这里已经是比较简单了，展开metamacro_head并且在所有参数最后添加了一个参数，继续展开metamacro_head_，得到展开过程如下 123NSInteger count = metamacro_head_(3, 2, 1, 0);NSInteger count = 3; 这里还有个巧妙之处就是展开metamacro_head_这个宏就是直接取了第一个参数作为结果。 到此为止，所有的宏被全部展开，得到最终的结果。 宏能用的这么巧妙，真是不得不佩服原作者。这样用宏来计算参数列表长度的方式不仅仅是将计算在预处理的搞定，更重要的是可以在编译时做检查，比如，某些函数的可变参数的要求是填入有限个参数，2个或3个或4个，只能是这3个选项，这样，只有这样的宏才能在编译前就提前检查出错误。 任何事情都是两面的，这个宏也存在弊端，就是只能计算20个参数以内(包含20个)的记过，但是我觉得这已经足够用了。","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-24T03:38:44.000Z","updated":"2017-10-24T08:41:19.000Z","comments":true,"path":"2017/10/24/hello-world/","link":"","permalink":"http://yoursite.com/2017/10/24/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Objective-C","slug":"Objective-C","permalink":"http://yoursite.com/tags/Objective-C/"}]}]}